"<head><style>.div1 {text-align: center;}</style></head>",
"<div class = \"div1\"><b>", DaneAgreg$JPT_NAZWA_, godzina, "</b></div>",
"ID: <b>", DaneAgreg$JPT_KOD_JE, "</b><br/>",
"Liczba pomiarów: <b>", DaneAgreg$LPunktow, "</b><br/>",
Nazwa_Wskaznika_Glob, ": <b>", round(DaneAgreg$Wartosc,2), Jednostka_Glob, "</b><br/>") %>%
lapply(htmltools::HTML)
leafletProxy("map", data = DaneFiltrowane) %>%
clearMarkers()  %>%
czyszczenie_shapeow() %>%
addPolygons(data = DaneAgreg, color = "#5e5e5e", smoothFactor = 0.3,
fillOpacity = 0.7, opacity = 1, weight = 0.8,
fillColor =  mypalette(DaneAgreg$Wartosc),
label = info,
labelOptions = labelOptions(
style = list(
"font-weight" = "normal",
"box-shadow" = "3px 3px rgba(0,0,0,0.25)",
"border-color" = "rgba(0,0,0,0.5)",
"font-family" = "Josefin Sans",
"background-color" = "#ededf7"
),
textsize = "13px", direction = "auto"),
layerId = ids
)
}
## CZĘŚĆ WŁAŚCIWA FUNKCJI MAPUJ()
OdwrocPalete_ <- if (input$zanieczyszczenieAirly %in% c("Wilgotność", "Deszcz", "Wilgotność gleby", "Wilgotność względna OpenMeteo 2m", "Prędkość wiatru")) {FALSE} else {TRUE}
klasyfikacja <- NULL
DaneDoPaletowania <- DaneCalyOkres
if (input$skalowanie == "Globalnie") {klasyfikacja <- normy[,indeks_zanieczyszczenia]}
else {klasyfikacja <- make_bins(10, DaneDoPaletowania)}
mypalette <- colorBin(palette = Paleta_Glob, domain = DaneDoPaletowania,
na.color = "transparent",
bins = klasyfikacja,
reverse = OdwrocPalete_)
raster_paleta <- colorBin(palette = colorRampPalette(RColorBrewer::brewer.pal(9, name = Paleta_Glob))(100), domain = DaneDoPaletowania,
na.color = "transparent",
bins = make_bins(100, klasyfikacja),
reverse = OdwrocPalete_)
godzina <- substr(as.character(input$hourSel), 12,16)
info <- paste( # Okno podręczne dla każdego czynnika
"<head><style>.div1 {text-align: center;}</style></head>",
"<div class = \"div1\"><b>", DaneFiltrowane$adres, godzina, "</b></div>",
"ID: <b>", DaneFiltrowane$id, "</b><br/>",
"Wysokość: <b>", DaneFiltrowane$elevation, "m</b><br/>",
Nazwa_Wskaznika_Glob, ": <b>", DaneFiltrowane$Czynnik, Jednostka_Glob, "</b><br/>")
leafletProxy("map") %>% clearMarkers()
if (input$zanieczyszczenieAirly == "Prędkość wiatru") {
info <- paste(info, "Kierunek wiatru: <b>", DaneFiltrowane$Kierunek, "°</b>")
for (i in 1:length(DaneFiltrowane$Kierunek)) {
ikona <- makeIcon(iconUrl = paste0("wind", DaneFiltrowane$Kierunek[i], ".png"))
leafletProxy("map") %>% addMarkers(DaneFiltrowane$lon[i], DaneFiltrowane$lat[i], icon = ikona)
}
}
info <- info %>% lapply(htmltools::HTML)
if (input$agregacja == "Punkty") {
czyszczenie_reszty <- function(map) {
if(poprzednie_wyswietlanie != "Punkty") {
poprzednie_wyswietlanie <<- "Punkty"
if(poprzednie_wyswietlanie == "Raster") return(clearImages(map))
else return(clearShapes(map))
} else {
return(addTiles(map))
}
}
leafletProxy("map", data = DaneFiltrowane) %>%
addCircleMarkers(~lon, ~lat,
fillColor = ~mypalette(Czynnik), fillOpacity = 1,
color="black", weight = 0.5, radius = 6, opacity = 0.5,
label = info,
labelOptions = labelOptions(
style = list(
"font-weight" = "normal",
"box-shadow" = "3px 3px rgba(0,0,0,0.25)",
"border-color" = "rgba(0,0,0,0.5)",
"font-family" = "Josefin Sans",
"background-color" = "#ededf7"
),
textsize = "13px", direction = "auto")
) %>%
czyszczenie_reszty()
}
else if (input$agregacja == "Gminy") {mapuj_jednostki(GminyMalopolskie, Paleta_Glob)}
else if (input$agregacja == "Powiaty") {mapuj_jednostki(PowiatyMalopolskie, Paleta_Glob)}
else if (input$agregacja == "Województwo") {mapuj_jednostki(WojMalopolskie, Paleta_Glob)}
else if (input$agregacja == "Ciągła") {
if (sum(!is.na(DaneFiltrowane$Czynnik)) > 0) {
raster <- kriging(DaneFiltrowane, WojShape, input$modelKriging, 2000)
czyszczenie_rastrow <- function(map) {
if(poprzednie_wyswietlanie != "Punkty" && poprzednie_wyswietlanie != "Raster") {
poprzednie_wyswietlanie <<- "Raster"
return(clearShapes(map))
} else if (poprzednie_wyswietlanie == "Punkty") {
poprzednie_wyswietlanie <<- "Raster"
return(clearMarkers(map))
} else return(clearImages(map))
}
leafletProxy("map", data = DaneFiltrowane) %>%
czyszczenie_rastrow() %>%
addRasterImage(raster, colors = raster_paleta, opacity = 0.75) %>%
addCircleMarkers(~lon, ~lat,
fillColor = ~mypalette(Czynnik), fillOpacity = 0.2,
color="black", weight = 0.5, radius = 6, opacity = 0.5,
label = info,
labelOptions = labelOptions(
style = list(
"font-weight" = "normal",
"box-shadow" = "3px 3px rgba(0,0,0,0.25)",
"border-color" = "rgba(0,0,0,0.5)",
"font-family" = "Josefin Sans",
"background-color" = "#ededf7"
),
textsize = "13px", direction = "auto")
)
}
}
})
# 5. Przybliżanie do punktu z eksploratora na mapę
observe({
if (is.null(input$goto))
return()
isolate({
map <- leafletProxy("map")
map %>% clearPopups()
dist <- 0.05
id <- input$goto$id
lat <- input$goto$lat
lng <- input$goto$lng
map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist)
})
})
# 6. Eksplorator danych
output$tabela <- DT::renderDataTable({
df <- data.frame(ID = filteredData()$id, "Adres czujnika" = filteredData()$adres,
Województwo = filteredData()$Województwo,
Powiat = filteredData()$Powiat,
Gmina = filteredData()$Gmina,
Wysokość = filteredData()$elevation,
Czynnik = filteredData()$Czynnik,
Lat = filteredData()$lat,
Long = filteredData()$lon,
check.names = FALSE) %>%
filter(
Czynnik >= input$minScore,
Czynnik <= input$maxScore,
is.null(input$powiaty) | Powiat %in% input$powiaty
) %>%
mutate(Action = paste('<a class="go-map" href="" data-lat="', Lat, '" data-long="', Long, '" data-id="', ID, '"><i class="fa fa-crosshairs"></i></a>', sep=""))
names(df)[names(df) == "Czynnik"] <- if(!is.null(input$zanieczyszczenieAirly)) {input$zanieczyszczenieAirly} else input$zanieczyszczenieOW
names(df)[names(df) == "Lat"] <- "Szerokość geograficzna"
names(df)[names(df) == "Long"] <- "Długość geograficzna"
names(df)[names(df) == "Action"] <- "Przybliż"
action <- DT::dataTableAjax(session, df, outputId = "tabela")
DT::datatable(df, options = list(ajax = list(url = action)), escape = FALSE)
})
# 7. Wykres
output$wykresCzynnika <- renderImage({
DaneFiltrowane <- filteredData()
wykreslaj <- function(Jednostka_ = "µg/m³", Paleta_ = "RdYlGn", OdwrocPalete_ = TRUE, LiniaMeteo_ = NULL) {
przedzial <- seq(poczatek_danych_okresowych, koniec_danych_okresowych)
if (sum(!is.na(DaneFiltrowane[przedzial])) == 0) {
return(plot(0, main = "Brak danych", xlab = "", ylab = "", xaxt = "none", yaxt = "none", pch = 20, cex = 0))
}
klasyfikacja <- NULL
DaneDoPaletowania <- DaneFiltrowane[przedzial]
if (input$skalowanie == "Globalnie") {klasyfikacja <- normy[,indeks_zanieczyszczenia]}
else {klasyfikacja <- make_bins(10, DaneDoPaletowania)}
mypalette <- colorBin(palette = Paleta_, domain = DaneDoPaletowania,
na.color = "transparent",
bins = klasyfikacja,
reverse = OdwrocPalete_)
dane <- rep(NA,length(przedzial))
it <- 0
for (j in przedzial) {
it <- it + 1
dane[it] <- mean(unlist(DaneFiltrowane[j]), na.rm = TRUE)
}
godziny <- round(seq(1, length(dane[!is.na(dane)]), length.out = 4))
maks <- max(dane,na.rm = TRUE)
mini <- min(dane,na.rm = TRUE)
windowsFonts(font = windowsFont("Josefin Sans"))
Godziny_Etykiety <- NULL
Gdzie_Zmiana_Doby <- NULL
Daty <- NULL
Godziny_Etykiety <- c(substr(as.character(DanePomiarowe$Dane$DATE[godziny]),12,16))
Gdzie_Zmiana_Doby <- which(nchar(as.character(unique(DanePomiarowe$Dane$DATE))) < 11)
Daty <- paste(substr(as.character(unique(DanePomiarowe$Dane$DATE)[Gdzie_Zmiana_Doby]),9,10), ".", substr(as.character(unique(DanePomiarowe$Dane$DATE)[Gdzie_Zmiana_Doby]),6,7), sep = "")
barplot(dane[!is.na(dane)],
main = input$zanieczyszczenieAirly,
xlab = "Godzina", ylab = paste("Wartość [", Jednostka_, "]", sep = ""),
xaxt = "none", yaxt = "none", xpd = FALSE, col = mypalette(dane),
space = 0, ylim = c(mini - (maks - mini) / 10, maks), cex.sub = 0.75,
family = "font", border = "#00000033", sub = "Niebieska linia - Historia / Prognoza")
axis(1, at = godziny, labels = Godziny_Etykiety, cex.axis = 0.85)
axis(2, at = tworz_sekwencje(mini, maks, 4, wlacznie_ = FALSE), cex.axis = 0.8)
abline(v = Gdzie_Zmiana_Doby, lwd = 3, col = "brown")
abline(v = Ile_Godzin - 24, lwd = 3, lty = 2, col = "#0000ff80")
for (i in 1:length(Gdzie_Zmiana_Doby)) {mtext(Daty[i], side = 3, line = 0, at = Gdzie_Zmiana_Doby[i], cex = 0.8)}
abline(v = Zmiana_Godziny_Glob + 0.5, lwd = 2, col = "black")
if (!is.null(LiniaMeteo_)) {
lines(1:length(dane[!is.na(dane)]), LiniaMeteo_[1:length(dane[!is.na(dane)])])
legend(cex = 0.7, x = "topleft", inset = c(-0.25, -0.3), legend = "OpenMeteo", lty = 1, col = "black", xpd = TRUE)
}
}
# A temp file to save the output.
# This file will be removed later by renderImage
outfile <- tempfile(fileext = '.png')
# Generate the PNG
png(outfile, width = 300, height = 250)
if (sum(input$zanieczyszczenieAirly == c("PM2.5", "PM10", "NO2", "SO2", "CO", "O3", "PM1")) > 0) {
wykreslaj()
}
else if (input$zanieczyszczenieAirly == "Ciśnienie") wykreslaj(Paleta_ = "YlGnBu", Jednostka_ = "hPa")
else if (input$zanieczyszczenieAirly == "Wilgotność") {
Linia <- NULL
for (i in 1:Ile_Godzin) Linia <- cbind(Linia, mean(DanePomiarowe$Dane[DanePomiarowe$Dane$DATE == DanePomiarowe$Dane$DATE[i], 2 + 12], na.rm = TRUE))
wykreslaj(Paleta_ = "YlGn", Jednostka_ = "%", OdwrocPalete_ =  FALSE, LiniaMeteo_ = Linia)
}
else if (input$zanieczyszczenieAirly == "Temperatura") {
Linia <- NULL
for (i in 1:Ile_Godzin) Linia <- cbind(Linia, mean(DanePomiarowe$Dane[DanePomiarowe$Dane$DATE == DanePomiarowe$Dane$DATE[i], 2 + 11], na.rm = TRUE))
wykreslaj(Paleta_ = "RdBu", Jednostka_ = "°C", LiniaMeteo_ = Linia)
}
else if (input$zanieczyszczenieAirly == "Temperatura gruntu") wykreslaj(Paleta_ = "RdBu", Jednostka_ = "°C")
else if (input$zanieczyszczenieAirly == "Punkt rosy 2m") wykreslaj(Paleta_ = "RdBu", Jednostka_ = "°C")
else if (input$zanieczyszczenieAirly == "Deszcz") wykreslaj(Paleta_ = "Blues", Jednostka_ = "mm", OdwrocPalete_ = FALSE)
else if (input$zanieczyszczenieAirly == "Prędkość wiatru") wykreslaj(Paleta_ = "YlOrRd", Jednostka_ = "km/h", OdwrocPalete_ = FALSE)
else if (input$zanieczyszczenieAirly == "Wilgotność gleby") wykreslaj(Paleta_ = "YlGn", Jednostka_ = "m³/m³", OdwrocPalete_ = FALSE)
dev.off()
list(src = outfile,
contentType = 'image/png',
width = 300,
height = 250,
alt = "This is alternate text")
}, deleteFile = TRUE)
# 8. Mapa w zakładce prognoza
output$map1 <- renderLeaflet({
# Oznaczenie granic województwa i powiatów na legendzie
kolory <- c(
"white; width:30px; height:9px; border:3px solid black; border-radius:0%",
"white; width:30px; height:9px; border:2px solid #5e5e5e; border-radius:0%"
)
tabele <- c(
"<div style='display: inline-block;'>Województwo</div>",
"<div style='display: inline-block;'>Powiat</div>"
)
pkt <- which(DanePomiarowe$Punkty$id == input$PointChoice)
wiatr <- DanePomiarowe$Dane$WINDDIRECTION_10M[DanePomiarowe$Dane$DATE == DanePomiarowe$Dane$DATE[Ile_Godzin - 24] & DanePomiarowe$Dane$ID == DanePomiarowe$Punkty$id[pkt]]
kat1 <- wiatr - 30
kat2 <- wiatr + 30
kat_pkt <- Katy[pkt,2:ncol(Katy)]
odl_pkt <- Odleglosci[pkt,2:ncol(Odleglosci)]
mypalette <- colorBin(palette = "RdYlGn", domain = odl_pkt,
na.color = "transparent",
bins = seq(0,max(odl_pkt, na.rm = TRUE), length.out = 10),
reverse = TRUE)
# Tworzę okrąg zniekształcony do elipsy ze względu na transformację współrzędnych
# geodezyjnych do geograficznych, aby linie były pozornie tej samej długości
p2 <- oblicz_elipse(DanePomiarowe$Punkty$location$longitude[pkt], DanePomiarowe$Punkty$location$latitude[pkt], kat1)
p3 <- oblicz_elipse(DanePomiarowe$Punkty$location$longitude[pkt], DanePomiarowe$Punkty$location$latitude[pkt], kat2)
p1 <- c(DanePomiarowe$Punkty$location$longitude[pkt], DanePomiarowe$Punkty$location$latitude[pkt])
p1 <- c(p1, p2[1], p2[2])
p1 <- c(p1, p3[1], p3[2])
poly <- sp::Polygon(cbind(p1[c(1,3,1,5)], p1[c(2,4,2,6)]))
poly <- sp::Polygons(list(poly), ID = "A")
poly <- sp::SpatialPolygons(list(poly))
info <- paste(
"<head><style>.div1 {text-align: center;}</style></head>",
"<div class = \"div1\">Punkt <b>", DanePomiarowe$Punkty$id, "</b></div>",
"Odległość: <b>", round(odl_pkt/1000,2), "km</b><br/>",
"Azymut: <b>", round(kat_pkt), "°</b>", sep = "") %>%
lapply(htmltools::HTML)
tag.map.title1 <- tags$style(HTML(".leaflet-control.map-title1 {
right: 0%;
top: 0px;
width: 100%;
padding-left: 10px;
padding-right: 10px;
background: rgba(255,255,255,0.75);
font-size: 15px;
box-shadow: 3px 3px 5px rgba(0,0,0,0.25);
border-radius: 5px;
font-family: Josefin Sans;
}"))
tytul1 <- tags$div(
tag.map.title1, HTML("Punkt <b>", DanePomiarowe$Punkty$id[pkt], "</b><br>Wiatr: <b>", wiatr, "°</b><br>W zasięgu: <b>", paste0(sum(kat_pkt < kat2 & kat_pkt > kat1), " pkt</b>",  sep = ""))
)
napisy_legenda <- paste0(round(seq(0,max(odl_pkt, na.rm = TRUE), length.out = 10)[1:9]/1000), "km")
leaflet(DanePomiarowe$Punkty) %>%
addTiles(group = "OSM (default)")  %>%
setView(lat = 49.775, lng = 20, zoom = 8) %>%
clearShapes() %>%
addPolygons(data = WojMalopolskie, color = "black", smoothFactor = 0.3,
fillOpacity = 0, opacity = 1, weight = 1.5) %>%
addPolygons(data = PowiatyMalopolskie, color = "#5e5e5e", smoothFactor = 0.3,
fillOpacity = 0, opacity = 1, weight = 0.8) %>%
leaflet::addLegend(title = "Podział administracyjny", colors = kolory,
labels = tabele, position = "bottomright") %>%
# Marker punktowy na punkt, dla którego liczymy prognozę
addCircleMarkers(lng = ~location$longitude[pkt], lat = ~location$latitude[pkt],
fillOpacity = 1, color = "blue", weight = 0.5, radius = 6, opacity = 1) %>%
# Markery punktowe dla punktów, które znajdują się na kącie skąd wieje wiatr
addCircleMarkers(lng = ~location$longitude[which(kat_pkt < kat2 & kat_pkt > kat1)],
lat = ~location$latitude[which(kat_pkt < kat2 & kat_pkt > kat1)],
fillColor = mypalette(odl_pkt[which(kat_pkt < kat2 & kat_pkt > kat1)]),
weight = 2, radius = 6, opacity = 1, color = "black", fillOpacity = 1) %>%
# Pozostałe markery (półprzezroczyste) - tak naprawdę nakładane na każdy punkt,
# żeby pojawiło się okno podręczne
addCircleMarkers(lng = ~location$longitude, lat = ~location$latitude, fillOpacity = 0.4, color = "black",
fillColor = ~mypalette(odl_pkt), weight = 0.5, radius = 6, opacity = 1,
label = info, labelOptions = labelOptions(
style = list(
"font-weight" = "normal",
"box-shadow" = "3px 3px rgba(0,0,0,0.25)",
"border-color" = "rgba(0,0,0,0.5)",
"font-family" = "Josefin Sans",
"background-color" = "#ededf7"
),
textsize = "13px", direction = "auto")) %>%
addPolygons(data = poly, color = "black", smoothFactor = 0.3,
fillOpacity = 0, opacity = 0.5, weight = 2) %>%
leaflet::addLegend(colors = mypalette(seq(0,max(odl_pkt, na.rm = TRUE), length.out = 10)[1:9]), labels = napisy_legenda,
values = odl_pkt, opacity = 0.8, title = "Odległości",
position = "bottomright") %>%
leaflet::addControl(tytul1, position = "topright", className = "map-title1") %>%
addScaleBar(position = "bottomleft")
})
# 9. Wykresy prognozy
output$PlotMain <- renderPlotly({
if (!is.null(v$data)) {
dane <- v$data
kk <<- dane
mse <- mean((dane$TEST[!is.na(dane$TEST)] - dane$PRED[!is.na(dane$PRED)])^2, na.rm = TRUE)
mae <- mean(abs(dane$PRED[!is.na(dane$PRED)] - dane$TEST[!is.na(dane$TEST)]), na.rm = TRUE)
maks <- as.numeric(dane$INFO[3])
mini <- as.numeric(dane$INFO[4])
dane$TRAIN <- dane$TRAIN * (maks - mini) + mini
dane$TEST <- dane$TEST * (maks - mini) + mini
dane$PRED <- dane$PRED * (maks - mini) + mini
info <- list(yref = 'paper', xref = "paper",
xanchor = "middle", yanchor = "top",
y = 1, x = 0.5, showarrow = FALSE,
text = paste0("MSE: ", round(mse*100,2), "%  MAE: ", round(mae*100,2), "%"),
font = list(size = 15))
zmiana_dnia <- which(hour(dane$DATE) == 0)
ktore_dni <- paste0(day(dane$DATE[hour(dane$DATE) == 0]), ".0", month(dane$DATE[hour(dane$DATE) == 0]))
p <- plot_ly(data = dane) %>%
layout(
title = list(text = paste0("<b>Prognoza ", dane$INFO[1], " z użyciem ", dane$INFO[2], " na 24h</b>"), font = czc1),
xaxis = list(title = list(text = "Dzień", font = czc),
ticktext = ktore_dni,
tickvals = zmiana_dnia
),
yaxis = list(title = list(text = paste0("Poziom ", dane$INFO[1], " [µg/m³]"), font = czc)),
annotations = info,
legend = list(title = list(text = "<b>Legenda</b>"))
) %>%
add_trace(x = 1:nrow(dane), y = ~TRAIN, mode = 'lines', name = "Dane treningowe",
line = list(size = 2, color = 'rgba(0, 0, 0, .9)'),
hovertemplate = '%{y:.2f}') %>%
add_trace(x = 1:nrow(dane), y = ~TEST, mode = 'lines+markers', name = "Dane testowe",
line = list(size = 2, color = 'rgba(100, 100, 100, .9)'),
marker = list(size = 5, color = 'rgba(100, 100, 100, .9)'),
hovertemplate = '%{y:.2f}') %>%
add_trace(x = 1:nrow(dane), y = ~PRED, mode = 'lines', name = "Prognoza",
line = list(size = 2, color = 'rgba(0, 255, 0, .9)'),
hovertemplate = '%{y:.2f}')
p
}
else {
plot_ly() %>%
layout(
title = list(text = "<b>Prognoza zanieczyszczenia powietrza</b>", font = czc1),
xaxis = list(title = list(text = "Dzień", font = czc)),
yaxis = list(title = list(text = "Poziom zanieczyszczenia [µg/m³]", font = czc))
)
}
})
output$Plot1 <- renderPlotly({
if(!is.null(v$data)) {
dane <- v$data
pearson <- cor(dane$TEST[!is.na(dane$TEST)][-1], dane$PRED[!is.na(dane$PRED)][-1])
info <- list(yref = 'paper', xref = "paper",
xanchor = "middle", yanchor = "top",
y = 1, x = 0.5, showarrow = FALSE,
text = paste0("Współczynnik korelacji: ", round(pearson,4)),
font = list(size = 10))
p <- plot_ly(data = dane, type = "scatter") %>%
add_trace(x = dane$TEST, y = dane$PRED, mode = "markers", name = "",
hovertemplate = paste('<i>Prog</i>: %{y:.2f}', '<br><i>Test</i>: %{x:.2f}<br>'),
showlegend = F) %>%
add_trace(data = dane, x = c(0,1), y=c(0,1) , mode="lines", name = "",
line = list(color = 'rgb(205, 12, 24)', width = 1, dash = 'dash'),
type = "scatter", showlegend = F) %>%
style(hoverinfo = "none") %>%
layout(
title = list(text = "Weryfikacja prognozy", font = czc1),
xaxis = list(title = list(text = "Wartości testowe", font = czc)),
yaxis = list(title = list(text = "Wartości prognozowane", font = czc)),
annotations = info
)
p
} else {
plot_ly() %>%
layout(
title = list(text = "Weryfikacja prognozy", font = czc1),
xaxis = list(title = list(text = "Wartości testowe", font = czc)),
yaxis = list(title = list(text = "Wartości prognozowane", font = czc))
)
}
})
output$Plot2 <- renderPlotly({
temp <- NULL
if (is.null(v$data)) {
temp <- data.frame(x=rep(NA,24),y=rep(NA,24))
plot_ly(data = temp, x = 1:24, y = ~y) %>%
layout(
title = list(text = "Mierniki jakości modelu", font = czc1),
xaxis = list(title = list(text = "Czas [h]", font = czc)),
yaxis = list(title = list(text = "Poziom PM10 [µg/m³]", font = czc))
)
} else if (input$Algorithm == "RF") {
temp <- data.frame(Drzewa = 1:length(v$model$mse), MSE = v$model$mse)
plot_ly(data = temp, x = ~Drzewa, y = ~MSE) %>%
add_trace(x = temp$Drzewa, y = temp$MSE, name = "",
hovertemplate = paste('<i>MSE</i>: %{y:.2%}', '<br><i>L.drzew</i>: %{x:.d}<br>'),
showlegend = F) %>%
layout(
title = list(text = "Błąd średniokwadratowy", font = czc1),
xaxis = list(title = list(text = "Ilość drzew", font = czc)),
yaxis = list(title = list(text = "MSE", font = czc))
)
} else if (input$Algorithm == "NN") plotly_nn(v$model, input$Pollution)
})
# 10. Prognoza
observeEvent(input$Start, {
idnt <- NULL
if (input$Pollution == "PM25") idnt <- input$PointChoice
else if (input$Pollution == "PM10") idnt <- input$PointChoice1
else if (input$Pollution == "PM1") idnt <- input$PointChoice2
temp <- DanePomiarowe$Dane[DanePomiarowe$Dane$ID == idnt,]
wybor <- data.frame(temp$ID, temp$DATE)
if (input$Pollution == "PM25") wybor <- cbind(wybor, temp$PM25)
else if (input$Pollution == "PM10") wybor <- cbind(wybor, temp$PM10)
else if (input$Pollution == "PM1") wybor <- cbind(wybor, temp$PM1)
colnames(wybor) <- c("ID", "DATE", "Czynnik")
if ("Temperatura" %in% input$VariablesPred) wybor$TEMPERATURE <- temp$TEMPERATURE
if ("Cisnienie" %in% input$VariablesPred) wybor$PRESSURE <- temp$PRESSURE
if ("Wilgotnosc" %in% input$VariablesPred) wybor$HUMIDITY <- temp$HUMIDITY
if ("Godzina" %in% input$VariablesPred) wybor$HOUR <- temp$HOUR
if ("Dzien" %in% input$VariablesPred) wybor$DAY <- temp$DAY
if ("PunktRosy" %in% input$VariablesPred) wybor$DEWPOINT_2M <- temp$DEWPOINT_2M
if ("Deszcz" %in% input$VariablesPred) wybor$RAIN <- temp$RAIN
if ("PredkoscWiatr" %in% input$VariablesPred) wybor$WINDSPEED_10M <- temp$WINDSPEED_10M
if ("KierunekWiatr" %in% input$VariablesPred) wybor$WINDDIRECTION_10M <- temp$WINDDIRECTION_10M
if ("TempGleb" %in% input$VariablesPred) wybor$SOIL_TEMPERATURE_0CM <- temp$SOIL_TEMPERATURE_0CM
if ("WilgGleb" %in% input$VariablesPred) wybor$SOIL_MOISTURE_0_TO_1CM <- temp$SOIL_MOISTURE_0_TO_1CM
if (ncol(wybor) < 4) {
v$data <- NULL
v$model <- NULL
return(0)
}
wybor <- utnij_braki(wybor)
wybor[,3:ncol(wybor)] <- usrednij_braki(wybor[,3:ncol(wybor)])
DaneLiczbowe <- apply(wybor, 2, function(x) as.numeric(as.character(x)))
maxs <- apply(DaneLiczbowe[,3:ncol(wybor)], 2, max) # Szukanie maksimum dla każdej kolumny
mins <- apply(DaneLiczbowe[,3:ncol(wybor)], 2, min) # Szukanie minimum dla każdej kolumny
maxs[maxs == 0] <- 1
sc_data <- data.frame(scale(DaneLiczbowe[,3:ncol(wybor)], center = mins, scale = maxs - mins)) #Skalowanie danych
train_data <- sc_data[1:(nrow(sc_data)-24),]
test_data <- sc_data[(nrow(sc_data)-23):nrow(sc_data),]
pred <- NULL
model <- NULL # Nazwy sieci neuronowej w dopełniaczu używane do nazwy wykresu
if (input$Algorithm == "RF") {
rf <- randomForest(Czynnik ~ ., data = train_data, ntree = input$nTree)
pred <- predict(rf, test_data)
model <- "lasu losowego"
v$model <- rf
}
else if (input$Algorithm == "NN") {
nn <- NULL
liniowy <- TRUE
if (!is.null(wybor$HOUR)) liniowy <- FALSE
if (input$nLayer == 1) {
nn <- neuralnet(Czynnik ~ ., data = train_data, stepmax = 1e8,
hidden = input$nLayer1, linear.output = liniowy)
pred <- predict(nn, test_data)
zmienna_glob <<- nn
} else if (input$nLayer == 2) {
nn <- neuralnet(Czynnik ~ ., data = train_data, stepmax = 1e8, linear.output = liniowy,
hidden = c(input$nLayer1, input$nLayer2))
pred <- predict(nn, test_data)
} else if (input$nLayer == 3) {
nn <- neuralnet(Czynnik ~ ., data = train_data, stepmax = 1e8, linear.output = liniowy,
hidden = c(input$nLayer1, input$nLayer2, input$nLayer3))
pred <- predict(nn, test_data)
}
v$model <- nn
model <- "sieci neuronowej"
}
v$data <- data.frame(
wybor$DATE,
c(train_data$Czynnik, rep(NA, nrow(test_data))),
c(rep(NA,nrow(train_data)-1), train_data$Czynnik[nrow(train_data)], test_data$Czynnik),
c(rep(NA,nrow(train_data)-1), train_data$Czynnik[nrow(train_data)], pred),
c(input$Pollution, model, maxs[1], mins[1], rep(NA,nrow(sc_data)-4))
)
colnames(v$data) <- c("DATE", "TRAIN", "TEST", "PRED", "INFO")
})
}
#### APLIKACJA ####
shinyApp(ui, server)
